---
title: "GraphQL vs REST API"
last_modified_at: 2024-09-30
author: 권수연
---

### GraphQL vs REST API: 차이점과 비교 분석

→ API(Application Programming Interface)는 클라이언트와 서버 간의 데이터를 주고받는 중요한 다리 역할을 합니다. 전통적으로 많이 사용된 방식은 **REST API**(Representational State Transfer)지만, 최근에는 **GraphQL**이 주목받고 있습니다. 두 가지 방식 모두 각자의 장점과 단점이 존재하며, 프로젝트의 성격에 따라 적합한 방식이 달라집니다.

---

### 1. **REST API란?**

REST API는 HTTP 프로토콜을 기반으로 서버와 클라이언트 간의 데이터 송수신을 하는 방식입니다. 주로 `GET`, `POST`, `PUT`, `DELETE`와 같은 HTTP 메서드를 사용하여 클라이언트가 서버의 리소스를 요청하거나 변경할 수 있습니다.

### **특징**:

- **HTTP 메서드 기반**: CRUD(생성, 읽기, 업데이트, 삭제) 작업을 HTTP 메서드에 따라 처리.
- **엔드포인트 중심**: 각 엔드포인트는 하나의 리소스 또는 작업을 나타냄. 예를 들어, `/users`는 사용자 목록을 반환하는 엔드포인트.
- **Stateless**: 서버는 각 요청을 독립적으로 처리하며, 클라이언트의 상태를 유지하지 않음.
- **JSON, XML 등 다양한 형식**: 데이터를 다양한 포맷으로 주고받을 수 있음.

### **REST API의 장점**:

- **표준화**: REST는 HTTP의 기본 규칙을 따르므로, HTTP와 관련된 툴과 서버에서 쉽게 사용 가능.
- **캐싱**: REST는 HTTP 프로토콜의 캐싱 메커니즘을 활용할 수 있어 성능 최적화에 유리.
- **분산 시스템에 적합**: 리소스 중심의 구조 덕분에 대규모 분산 시스템에 적합.

### **REST API의 단점**:

- **과도한 데이터 전송**: 클라이언트가 필요로 하는 것보다 많은 데이터를 가져올 수 있음. 이를 **Over-fetching**이라고 함.
- **여러 엔드포인트 관리**: 특정한 데이터 구조를 위해 여러 엔드포인트를 호출해야 할 수 있음.
- **유연성 부족**: 클라이언트가 요청할 수 있는 데이터 구조가 서버에서 미리 정의됨.

---

### 2. **GraphQL이란?**

GraphQL은 2012년 Facebook에서 개발한 API 쿼리 언어입니다. REST와 달리 고정된 엔드포인트가 아닌 하나의 엔드포인트에서 클라이언트가 원하는 데이터만을 쿼리할 수 있는 방식을 제공합니다.

### **특징**:

- **단일 엔드포인트**: 모든 요청이 하나의 엔드포인트에서 처리됨. 클라이언트가 필요로 하는 데이터만 쿼리할 수 있음.
- **타입 시스템**: GraphQL 스키마는 엄격한 타입 시스템을 사용하여 API의 구조를 정의함.
- **효율적 데이터 요청**: 필요한 데이터만 가져올 수 있어 과도한 데이터 전송 문제를 해결.

### **GraphQL의 장점**:

- **Over-fetching과 Under-fetching 해결**: 클라이언트가 원하는 데이터만 정확하게 요청할 수 있어, 데이터 낭비를 줄임.
- **단일 요청**: 여러 리소스를 하나의 요청에서 처리 가능. 이를 통해 REST에서 발생할 수 있는 다중 엔드포인트 요청 문제를 해결.
- **유연성**: 클라이언트가 요청하는 데이터의 구조를 자유롭게 정의할 수 있어 다양한 요구사항을 충족할 수 있음.
- **타입 시스템**: 강력한 타입 시스템을 통해 API의 구조를 명확하게 정의하고, 클라이언트-서버 간 통신 오류를 줄일 수 있음.

### **GraphQL의 단점**:

- **복잡한 서버 설정**: REST API에 비해 GraphQL 서버는 초기 설정이 더 복잡할 수 있음.
- **캐싱 어려움**: GraphQL은 REST처럼 HTTP 캐싱을 쉽게 사용할 수 없어, 별도의 캐싱 전략이 필요함.
- **오버헤드 발생 가능**: 클라이언트가 과도하게 복잡한 쿼리를 요청할 경우, 서버에 부담이 될 수 있음.

---

### 3. **REST vs GraphQL: 비교 분석**

| **특징**             | **REST API**                                                    | **GraphQL**                                                      |
| -------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------- |
| **엔드포인트 구조**  | 여러 엔드포인트에서 각 리소스에 대한 요청 처리                  | 단일 엔드포인트에서 모든 요청 처리                               |
| **데이터 전송 방식** | 고정된 형식의 응답, 클라이언트는 정해진 형식에 따라 데이터 수신 | 원하는 데이터만 쿼리할 수 있어 과도한 데이터 전송 방지           |
| **캐싱**             | HTTP 캐싱을 쉽게 활용 가능                                      | HTTP 캐싱 활용이 어려워 별도의 캐싱 전략 필요                    |
| **타입 시스템**      | 없음                                                            | 강력한 타입 시스템을 통해 API 구조 명확히 정의                   |
| **설정 복잡성**      | 간단한 초기 설정                                                | 초기 설정이 복잡할 수 있음                                       |
| **성능 최적화**      | 불필요한 데이터 전송이 있을 수 있음                             | 필요한 데이터만 쿼리할 수 있어 네트워크 최적화 가능              |
| **사용 사례**        | 표준화된 분산 시스템, 리소스 기반 API에 적합                    | 데이터 관계가 복잡하고, 다양한 요구사항을 가진 클라이언트에 적합 |

---

### 4. **각 방식의 사용 사례**

### **REST API가 적합한 경우**:

- **단순한 데이터 구조**: 기본적인 CRUD 기능을 제공하는 간단한 API라면 REST가 더 적합할 수 있습니다.
- **HTTP 프로토콜의 기능을 적극적으로 활용해야 하는 경우**: HTTP 캐싱이나 상태 코드 관리가 중요한 경우 REST가 유리합니다.
- **규모가 큰 분산 시스템**: 여러 리소스를 다양한 엔드포인트로 나누어 관리하는 대규모 분산 시스템에 적합합니다.

### **GraphQL이 적합한 경우**:

- **복잡한 데이터 관계**: GraphQL은 여러 관계를 가진 복잡한 데이터 모델을 관리하는 데 적합합니다. 예를 들어, 사용자, 게시글, 댓글 등 여러 리소스가 연결된 소셜 네트워크 같은 애플리케이션에서 유용합니다.
- **다양한 클라이언트 요구사항**: 모바일, 웹, 데스크톱 클라이언트가 각기 다른 데이터 구조를 필요로 할 때, GraphQL은 이를 유연하게 처리할 수 있습니다.
- **효율적인 데이터 전송이 필요한 경우**: 클라이언트가 필요한 데이터만 쿼리할 수 있기 때문에 데이터 낭비를 줄일 수 있습니다.

---

### 5. **보안 측면에서의 비교**

REST와 GraphQL 모두 보안에 대한 고려가 필요하지만, 각 방식에 따라 접근해야 하는 보안 전략이 다릅니다.

#### **5.1 REST API 보안**

- **인증 및 권한 부여**: 일반적으로 OAuth, JWT 토큰, API 키를 사용하여 보안을 유지하며, 각 엔드포인트에 대한 접근 권한을 별도로 관리할 수 있습니다.
- **HTTP 메서드 기반의 보안**: REST API는 각 메서드(`GET`, `POST`, `PUT`, `DELETE`)에 대해 권한을 설정할 수 있어, 특정 리소스에 대한 접근을 제한하는 것이 용이합니다.
- **속도 제한**: 특정 시간 내에 허용되는 요청 수를 제한하여 DoS 공격을 방지하는 등 속도 제한(rate limiting)을 쉽게 적용할 수 있습니다.

#### **5.2 GraphQL 보안**

- **인증 및 권한 부여**: GraphQL도 JWT 토큰이나 OAuth 등을 통해 보안을 유지할 수 있지만, 필드 수준의 세밀한 권한 관리를 위해 추가적인 노력이 필요합니다.
- **복잡한 쿼리 문제**: 클라이언트가 복잡한 쿼리를 요청할 경우 서버에 부담을 줄 수 있으므로, **쿼리 깊이 제한**(query depth limiting)이나 **쿼리 비용 분석**(query cost analysis)을 통해 방어해야 합니다.
- **속도 제한**: REST와 마찬가지로 속도 제한을 적용할 수 있지만, 단일 엔드포인트에서 모든 요청이 처리되기 때문에 더욱 신중하게 관리해야 합니다.

---

### 6. **성능 최적화 전략 비교**

#### **6.1 REST API의 성능 최적화**

- **캐싱**: HTTP 캐싱을 활용하여 응답을 저장하고, 클라이언트가 동일한 데이터를 여러 번 요청하는 경우 서버 부하를 줄일 수 있습니다.
- **CDN(Content Delivery Network)**: 정적 리소스(이미지, CSS, JavaScript 파일 등)를 캐시하고 제공하여 빠른 응답을 보장할 수 있습니다.
- **페이징(Pagination)**: 대량의 데이터를 한 번에 전송하지 않고 페이지 단위로 나누어 전송함으로써 클라이언트와 서버의 부하를 줄일 수 있습니다.

#### **6.2 GraphQL의 성능 최적화**

- **데이터 로더(DataLoader)**: GraphQL에서 발생하는 N+1 문제를 해결하기 위해 페이스북에서 만든 `DataLoader`를 사용하여 동일한 데이터를 배치 처리할 수 있습니다.
- **지연 로딩(Lazy Loading)**: 필요하지 않은 데이터는 쿼리하지 않도록 설계하여 불필요한 데이터 전송을 최소화할 수 있습니다.
- **필드 수준 캐싱**: 각 필드의 데이터를 캐싱하여 동일한 요청이 반복될 때 성능을 향상시킬 수 있습니다.

---

### 7. **버전 관리의 차이**

#### **7.1 REST API의 버전 관리**

- REST API는 일반적으로 엔드포인트 URL에 버전을 포함하여 `/v1/users`, `/v2/users`와 같은 방식으로 버전을 관리합니다.
- 새로운 버전을 출시할 때 기존 API는 유지되므로, 클라이언트는 필요한 시점에 새로운 버전으로 전환할 수 있습니다.

#### **7.2 GraphQL의 버전 관리**

- GraphQL은 하나의 엔드포인트를 사용하므로 버전 관리를 위해 별도의 엔드포인트를 생성하지 않습니다.
- 대신, 스키마를 점진적으로 발전시키는 방식으로 버전 관리를 수행합니다. 즉, 새로운 필드를 추가하거나 불필요한 필드는 점진적으로 폐기(Deprecation)하는 방식으로 API를 진화시킵니다.

---

### 8. **실제 사용 사례와 경험 공유**

- **GitHub API**: GitHub은 REST API에서 GraphQL로 전환한 대표적인 사례입니다. 이를 통해 단일 요청으로 다양한 리소스에 접근할 수 있게 되었으며, 복잡한 데이터를 효율적으로 가져올 수 있게 되었습니다.
- **Shopify**: Shopify는 GraphQL을 도입하여 클라이언트가 필요한 데이터를 정확하게 가져올 수 있도록 지원하고 있으며, 다양한 디바이스에 맞춘 최적화된 데이터 제공을 실현하고 있습니다.
- **Twitter API**: 반면 Twitter는 REST API를 유지하고 있으며, 간단한 데이터 구조와 빠른 캐싱을 활용하여 높은 성능과 확장성을 유지하고 있습니다.

---

### 9. **최신 트렌드와 미래 전망**

GraphQL과 REST API 모두 지속적으로 발전하고 있으며, 각 방식의 최신 트렌드와 미래 전망은 다음과 같습니다.

- **GraphQL Federation**: 마이크로서비스 환경에서 여러 GraphQL 서비스들을 통합하여 하나의 API로 노출할 수 있는 기능이 주목받고 있습니다. 이를 통해 마이크로 프론트엔드 및 백엔드 환경에서 더욱 유연한 통합이 가능해졌습니다.
- **REST API의 OpenAPI/Swagger**: REST API는 OpenAPI/Swagger를 활용하여 API 문서를 자동으로 생성하고, 개발자 간의 협업을 더욱 쉽게 해주는 표준화 도구가 꾸준히 사용되고 있습니다.
- **하이브리드 접근**: 일부 기업들은 REST API와 GraphQL을 함께 사용하는 하이브리드 접근 방식을 도입하고 있습니다. REST의 단순성과 GraphQL의 유연성을 모두 활용하여 각 방식의 장점을 최대화하는 추세가 나타나고 있습니다.
